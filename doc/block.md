
##Блоки

###Основы

Условия работы с блоками идентичны работе с моделями. 

Обычно приложение состоит из основного контента и дополнительных блоков на страницы.
Например, такими элементами можно назвать блоки вертикального меню, блок с вводом логина и пароля, блок горизонтальной навигации. 
У всех этих блоков есть своя логика работы, которую просто неудобно реализовывать напрямую в контролере.

Блоки могут получать информацию, обрабатывать её и отдавать контент пользователю. Для выполнения этой работы на помощь приходит механизм работы с блоками.

Пользовательские блоки должны храниться в директории `/app/blocks/`, директория может иметь вложенные папки.

Доступ к блоку осуществляется "точечным путем" `dir.subdir.name`, а имя класса такого блока должно иметь вид `Dir_Subdir_Name_Block`.

В директории `/app/blocks/` могут быть приватные папки имя которых начинается с "_" - нижние подчеркивание.
Такие папки недоступны по точечному пути и могут хранить вспомогательные классы блоков. 

Используя приватные папки можно делать более сложные блоки, методы которых возвращают другой объект связанный с этим блоком, но реализация которого вынесена за пределы этого блока.

###Доступ

Предположим, у нас имеется блок, `tags.php` который расположен в директории `/app/blocks/menu/`.
К такому блоку можно обратиться, используя путь `menu.tags`, а имя его класса должно иметь вид `Menu_Tags_Block`.

```php
class Menu_Tags_Block
{	
	public function view()
	{		
		return View::make('main.menu.tags', array());
	}

	public function __toString()
	{
		return $this->view()->compile();
	}
}
```

Теперь мы можем обратиться к методам этого блока.

```php
$tabs_html = Block::get('menu.tags')->view();
```

####Собирем меню из нескольких блоков

```php
$menu_blocks = array();
$menu_blocks[] = Block::get('menu.post')->view();
$menu_blocks[] = Block::get('menu.tags')->view();
$menu_blocks[] = Block::get('menu.last')->view();
$menu_blocks[] = Block::get('menu.action')->view();

```

####Добавим ещё один блок после первого

```php
if($read_block) {
	array_insert($menu_blocks, 2, Block::get('menu.read')->view());
}
```

####Используем буферизацию блоков с отложенным выполнением

```php
Block::buffer('menu')->add('menu.post');
Block::buffer('menu')->add('menu.tags');
Block::buffer('menu')->add('menu.last');
Block::buffer('menu')->add('menu.action');

echo Block::buffer('menu')->flush();
```

####Добавляем ещё блок вторым элементом

```php
Block::buffer('menu')->add('menu.best', 2);
```

####Меняем позицию блока в буфере

```php
Block::buffer('menu')->pos('menu.post', 3);
```

####Получаем объект конкретного блока

```php
Block::buffer('menu')->get('menu.post')->post_id = '1567'; // передадим какой-нибудь параметр в блок
```

####Удаляем блок из выдачи

```php
Block::buffer('menu')->del('menu.post');
```

####Очищаем буфер

```php
Block::buffer('menu')->clear();
```

####Получение буфера

```php
Block::buffer('menu')->flush();
```

> **Важно:** Используя буферизацю блоков, у каласса блока необходимо реализовать
магический метод __toString для возвращения стокового значения объекта.
